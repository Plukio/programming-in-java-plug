<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>reveal.js</title>

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/motyka.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>
<body>
<div class="reveal">
	<div class="slides">
		<section data-background-color="#523996">
			<i>Week 2 | Lesson 9</i>
			<h1>The SOLID Principle</h1>
			<em>Object Oriented Design Patterns</em><br />
			<em>I/mutability, state and functional programming principles</em><br />
			<em>Generics</em>
		</section>
		<section>
			<section data-background-color="#523996">
				<h2>The SOLID Principle</h2>
			</section>
			<section>
				<h3>The SOLID Principle</h3>
				<p>
					The <strong>SOLID</strong> principle is a set of five principles that help us write better code,
					making it more maintainable, readable, and easier to upgrade and modify.
				</p>
				<p>
					These principles are not specific to Java, but they are applicable to any object-oriented language.
				</p>
				<p>
					The <strong>SOLID</strong> principle is an acronym for the following:
				</p>
				<ul>
					<li><strong>S</strong>ingle Responsibility Principle</li>
					<li><strong>O</strong>pen/Closed Principle</li>
					<li><strong>L</strong>iskov Substitution Principle</li>
					<li><strong>I</strong>nterface Segregation Principle</li>
					<li><strong>D</strong>ependency Inversion Principle</li>
				</ul>
			</section>
			<section>
				<h4>Single Responsibility Principle</h4>
				<hr />
				<p>
					<em>
						Each class should have a single responsibility or reason to change.
						This helps to build a system that is better defined, modular, and easier to maintain.
					</em>
				</p>
				<hr />
				<p>
					We have seed this principle applied when we talked about encapsulation. Also, you will
					find that if this principle is applied correctly, your code will be much easier to test.
				</p>
			</section>
			<section>
				<h4>Open/Closed Principle</h4>
				<hr />
				<p>
					<em>
						Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification.
						This prevents issues introduced by changes to existing code.
					</em>
				</p>
				<hr />
				<ul style="font-size: 80%">
					<li>
						<strong>Open for extension</strong><br />
						means that the class should be designed in such a way that
						it can be extended to perform new things.
						<br />
						<br />
						Example of this would be extending class with methods to handle new requirements without modifying the existing ones.</sub>
					</li>
					<li>
						<strong>Closed for modification</strong><br />
						means that once the class has been developed and tested, the code behavior must not change.
						<br />
						<br />
						Example of this would be that the class should not be modified to handle new requirements,<br />
						but rather extended, as explained above.
					</li>
				</ul>
			</section>
			<section>
				<h4>Liskov Substitution Principle</h4>
				<hr />
				<p>
					<em>
						<!--					This is a specific definition of a kind of substitutability on strong behavioral subtyping.-->
						<!--					It indicates that one should be able to use any derived class instead of a parent class and have it behave in the same manner without modification.-->
						One should be able to use any derived class instead of a parent class and have it behave in the same manner without modification.
					</em>
				</p>
				<hr />
				<p>
					We have already seen the Liskov principle applied when we worked with inheritance, abstract classes and interfaces.
				</p>
			</section>
			<section>
				<h4>Interface Segregation Principle</h4>
				<hr />
				<p>
					<em>
						Many specific client-specific interfaces are better than one general-purpose interface.
						This means that you should not impose the clients with interfaces that they don't use.
					</em>
				</p>
				<hr />
				<p>
					Imagine you have a class that represents a printer.
					You could have the class implement one interface with methods print(), scan(), etc.
				</p>
				<pre>
					<code data-trim data-noescape data-line-numbers class="hljs java">
						interface Printer {
							void print();
							void scan();
						}

						class SimplePrinter implements Printer {}
						class MultiPrinter implements Printer {}
					</code>
				</pre>
				<p>
					Or you could have the class implement multiple interfaces, each with a single method.
					<!--						<br />-->
					<!--						<br />-->
					<!--						Simply put, don't clutter your code with stuff you won't use.-->
				</p>
				<pre>
					<code data-trim data-noescape data-line-numbers class="hljs java">
						interface Printing {
							void print();
						}

						interface Scanning {
							void scan();
						}

						class SimplePrinter implements Printing {}
						class MultiPrinter implements Printing, Scanning {}
					</code>
				</pre>
			</section>
			<section>
				<h4>Dependency Inversion Principle</h4>
				<hr />
				<p>
					<em>
						One should depend upon abstractions, rather than concrete implementations.
						This way, modules can remain decoupled, leading to systems that are easier to refactor, change, and deploy.
					</em>
				</p>
				<hr />
				<p>
					This is commonly demonstrated when working with collections.
					We will also see how this is helpful once we start developing applications using Inversion of Control.
				</p>
			</section>
		</section>
		<section>
			<section data-background-color="#523996">
				<h2>Inversion of Control</h2>
			</section>
			<section>
				<h3>Inversion of Control (IoC)</h3>
				<p>
					Inversion of Control is a principle in software engineering by which the control is transferred
					from higher-level components to the lower-level components
				</p>
				<p>
					This allows the higher-level and lower-level components to focus on their functionalities,
					promotes better decoupling, more flexibility, and easier maintenance.
				</p>
			</section>
			<section>
				<h3>Dependency Injection</h3>
				<p>
					Dependency Injection is a design pattern that implements IoC.
					It allows us to inject dependencies into a class, rather than creating them inside the class.
				</p>
				<p>
					There are three types of dependency injection:
				</p>
				<ul>
					<li>Constructor Injection</li>
					<li>Setter Injection</li>
					<li>Interface Injection</li>
				</ul>
			</section>
			<section>
				<h4>Without Injection</h4>
				<em>
					This example is not using dependency injection. The Car class is tightly coupled with the ElectricEngine class.
				</em>
				<div class="row">
					<pre>
					<code data-trim data-noescape data-line-numbers class="hljs java">
						public class NoInjectionExample {

							public static void main(String[] args) {
								Car car = new Car();
								car.start();
								car.stop();
							}

						}
					</code>
					</pre>
					<div class="column">
						<pre>
							<code data-trim data-noescape data-line-numbers class="hljs java">
								public interface Engine {
									void on();
									void off();
								}
							</code>
						</pre>
						<pre>
							<code data-trim data-noescape data-line-numbers class="hljs java">
								public class ElectricEngine implements Engine {

									@Override
									public void on() {
										System.out.println("Diesel engine started");
									}

									@Override
									public void off() {
										System.out.println("Diesel engine stopped");
									}
								}
							</code>
						</pre>
					</div>
					<div class="column">
						<pre>
							<code data-trim data-noescape data-line-numbers class="hljs java">
								public class Car {

									// dependency is hardcoded
									private Engine engine = new ElectricEngine();

									void start() {
										engine.on();
									}

									void stop() {
										engine.off();
									}

								}
							</code>
						</pre>
					</div>
				</div>
			</section>
			<section>
				<h4>Constructor Injection</h4>
				<em>
					This example is using constructor injection. The Engine dependency is injected into the Car class through its constructor.
				</em>
				<div class="row">
					<pre>
					<code data-trim data-noescape data-line-numbers class="hljs java">
						public class ConstructorInjectionExample {

							public static void main(String[] args) {
								// First, we need to create an instance of the dependency
								Engine engine = new ElectricEngine();
								// Then we inject the dependency via constructor
								Car car = new Car(engine);
								car.start();
								car.stop();
							}

						}
					</code>
					</pre>
					<div class="column">
						<pre>
							<code data-trim data-noescape data-line-numbers class="hljs java">
								public interface Engine {
									void on();
									void off();
								}
							</code>
						</pre>
						<pre>
							<code data-trim data-noescape data-line-numbers class="hljs java">
								public class ElectricEngine implements Engine {

									@Override
									public void on() {
										System.out.println("Diesel engine started");
									}

									@Override
									public void off() {
										System.out.println("Diesel engine stopped");
									}
								}
							</code>
						</pre>
					</div>
					<div class="column">
						<pre>
							<code data-trim data-noescape data-line-numbers class="hljs java">
								public class Car {

									private final Engine engine;

									// dependency is injected via constructor
									Car(Engine engine) {
										this.engine = engine;
									}

									void start() {
										engine.on();
									}

									void stop() {
										engine.off();
									}

								}
							</code>
						</pre>
					</div>
				</div>
			</section>
			<section>
				<h4>Setter Injection</h4>
				<em>
					This example is using setter injection. The Engine dependency is injected into the Car class through its setter.
				</em>
				<div class="row">
					<pre>
					<code data-trim data-noescape data-line-numbers class="hljs java">
						public class SetterInjectionExample {

							public static void main(String[] args) {
								// First, we need to create an instance of the dependency
								Engine engine = new ElectricEngine();
								// Then we create an instance of the class that has the dependency
								Car car = new Car();
								// Then we inject the dependency via setter
								car.setEngine(engine);
								car.start();
								car.stop();
							}

						}
					</code>
					</pre>
					<div class="column">
						<pre>
							<code data-trim data-noescape data-line-numbers class="hljs java">
								public interface Engine {
									void on();
									void off();
								}
							</code>
						</pre>
						<pre>
							<code data-trim data-noescape data-line-numbers class="hljs java">
								public class ElectricEngine implements Engine {

									@Override
									public void on() {
										System.out.println("Diesel engine started");
									}

									@Override
									public void off() {
										System.out.println("Diesel engine stopped");
									}
								}
							</code>
						</pre>
					</div>
					<div class="column">
						<pre>
							<code data-trim data-noescape data-line-numbers class="hljs java">
								public class Car {

									private Engine engine;

									// dependency is injected via setter
									void setEngine(Engine engine) {
										this.engine = engine;
									}

									void start() {
										engine.on();
									}

									void stop() {
										engine.off();
									}

								}
							</code>
						</pre>
					</div>
				</div>
			</section>
			<section>
				<h4>Interface Injection</h4>
				<em>
					This example is using interface injection.
				</em>
				<div class="row">
					<pre>
					<code data-trim data-noescape data-line-numbers class="hljs java">
						// TODO
						// TODO
						// TODO
						// TODO
						// TODO
					</code>
					</pre>
					<div class="column">
						<pre>
							<code data-trim data-noescape data-line-numbers class="hljs java">
								interface Engine {
									void on();
									void off();
								}
							</code>
						</pre>
						<pre>
							<code data-trim data-noescape data-line-numbers class="hljs java">
								class ElectricEngine implements Engine {

									@Override
									public void on() {
										System.out.println("Diesel engine started");
									}

									@Override
									public void off() {
										System.out.println("Diesel engine stopped");
									}
								}
							</code>
						</pre>
					</div>
					<div class="column">
						<pre>
							<code data-trim data-noescape data-line-numbers class="hljs java">
								class Car {

									// dependency is hardcoded
									Engine engine = new ElectricEngine();

									void start() {
										engine.on();
									}

									void stop() {
										engine.off();
									}

								}
							</code>
						</pre>
					</div>
				</div>
			</section>
		</section>

		<section>
			<section data-background-color="#523996">
				<h2>Generics</h2>
			</section>
			<section>
				<h3>Generics</h3>
				<p>
					Generics allow us to create classes, interfaces, and methods that take types as parameters.
				</p>
				<p>
					They are a way to make our code more reusable by allowing us to use the same code with different types.
				</p>
			</section>
			<section>
				<h3>Generics</h3>
				<p>
					In this example, we define a LinkedList, and add an element to it.
					The compiler will not complain about this, at this point, it knows we are adding a String to the list.
				</p>
				<p>
					However, when we try to get the element from the list, the compiler will complain,
					because it doesn't know what type of element is in the list.
				</p>
				<pre>
					<code data-trim data-noescape data-line-numbers="|5|8|" class="hljs java">
						public class GenericsExample {

							public static void main(String[] args) {

								List list = new LinkedList();
								list.add("Hello World");

								String str = list.get(0); // compiler will complain about this
							}

						}
					</code>
				</pre>
				<p>
					To fix this, we can tell the compiler what type of elements are in the list.
				</p>
				<pre>
					<code data-trim data-noescape data-line-numbers="|5|8|" class="hljs java">
						public class GenericsExample {

							public static void main(String[] args) {

								List&lt;String&gt; list = new LinkedList<>();
								list.add("Hello World");

								String str = list.get(0); // this is OK
							}

						}
					</code>
				</pre>
			</section>
			<section>
				<h3>How to Define Generics</h3>
				<p>
					To use generics, we need to define them in the class or interface declaration.
					This is done by using angle brackets and the type parameter name, in this case, <code>T</code>.
				</p>
				<p>
					We can then use the type parameter with attributes, methods, and constructors.
				</p>
				<div class="row">
					<div class="column">
						<pre>
							<code data-trim data-noescape data-line-numbers="|1|3,5,9|" class="hljs java">
								class Sensor&lt;T&gt; {

									private T id;

									public Sensor(T id) {
										this.id = id;
									}

									public T getId() {
										return id;
									}

								}
							</code>
						</pre>
					</div>
					<div class="column">
						<pre>
							<code data-trim data-noescape data-line-numbers="|5,8|" class="hljs java">
								public class GenericsExample {

									public static void main(String[] args) {

										Sensor&lt;String&gt; sensor1 = new Sensor<>("ABC");
										System.out.println(sensor1.getId());

										Sensor&lt;Integer&gt; sensor2 = new Sensor<>(123);
										System.out.println(sensor2.getId());

									}

								}
							</code>
						</pre>
					</div>
				</div>
				<sub>
					We can use any name for the type parameter, but it is common to use single uppercase letters.
				</sub>
			</section>
		</section>
		<section>
			<section data-background-color="#523996">
				<h2>Optionals</h2>
			</section>
			<section>
				<h3>Optionals</h3>
			</section>
		</section>
		<section>
			<section data-background-color="#523996">
				<h2>Lambda expressions</h2>
				<h2>Repetition</h2>
			</section>
			<section>
				<h3>Lambda expressions</h3>
			</section>
		</section>
		<section>
			<section data-background-color="#523996">
				<h2>Immutability, State, Functional Programming</h2>
			</section>
			<section>
				<h3>Subtopic</h3>
				<p>
					So far, we have been using <strong>imperative programming</strong> style for working with collections.
					The imperative style is characterized by explicit statements that change a program's state.

					Functional programming is a programming paradigm that treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data.
				</p>
			</section>
		</section>
		<section>
			<section data-background-color="#523996">
				<h2>Practice</h2>
			</section>
		</section>
	</div>
</div>

<script src="dist/reveal.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script>
	// More info about initialization & config:
	// - https://revealjs.com/initialization/
	// - https://revealjs.com/config/
	Reveal.initialize({
		hash: true,

		// Learn about plugins: https://revealjs.com/plugins/
		plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
	});
</script>
</body>
</html>
